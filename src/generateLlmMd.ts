// Generated by Gemini-CLI.

interface JSDocTag {
  kind: string;
  name?: string;
  doc?: string;
}

interface JSDoc {
  doc?: string;
  tags?: JSDocTag[];
}

interface Node {
  name: string;
  kind: string;
  jsDoc?: JSDoc;
}

interface DocsData {
  version: number;
  nodes: Node[];
}

const docsJsonPath = "./docs.json";
const outputMdPath = "./llm.md";

const docsData: DocsData = JSON.parse(await Deno.readTextFile(docsJsonPath));

let markdownContent = "# Journalism Library Documentation for LLM\n\n";
markdownContent +=
  "This document provides a comprehensive overview of the Journalism library's functions and their usage, specifically formatted for consumption by a Large Language Model (LLM). Each function includes its description, parameters, and examples.\n\n";

const categories: { [key: string]: Node[] } = {};

for (const node of docsData.nodes) {
  if (node.kind === "function" || node.kind === "class") {
    let category = "Uncategorized";
    if (node.jsDoc && node.jsDoc.tags) {
      for (const tag of node.jsDoc.tags) {
        if (tag.kind === "category" && tag.doc) {
          category = tag.doc;
          break;
        }
      }
    }
    if (!categories[category]) {
      categories[category] = [];
    }
    categories[category].push(node);
  } else if (node.kind === "moduleDoc" && node.jsDoc && node.jsDoc.tags) {
    for (const tag of node.jsDoc.tags) {
      if (tag.kind === "module" && tag.name) {
        markdownContent += `## Module Overview\n\n${
          tag.name.replace(/\n/g, " ")
        }\n\n`;
      }
    }
  }
}

const sortedCategories = Object.keys(categories).sort();

for (const category of sortedCategories) {
  markdownContent += `## ${category}\n\n`;
  for (const node of categories[category]) {
    const name = node.name || "Unnamed";
    const doc = node.jsDoc?.doc?.replace(/\n/g, " ") ||
      "No description available.";

    markdownContent += `### \`${name}\`\n\n`;
    markdownContent += `${doc}\n\n`;

    if (node.jsDoc && node.jsDoc.tags) {
      const params = node.jsDoc.tags.filter((tag) => tag.kind === "param");
      const examples = node.jsDoc.tags.filter((tag) => tag.kind === "example");

      if (params.length > 0) {
        markdownContent += "**Parameters:**\n\n";
        for (const param of params) {
          const paramName = param.name || "N/A";
          const paramDoc = param.doc?.replace(/\n/g, " ") ||
            "No description.";
          markdownContent += `- \`${paramName}\`: ${paramDoc}\n`;
        }
        markdownContent += "\n";
      }

      if (examples.length > 0) {
        markdownContent += "**Examples:**\n\n";
        for (const example of examples) {
          const exampleDoc =
            example.doc?.replace(/```ts\n/g, "```typescript\n") ||
            "No example provided.";
          markdownContent += `${exampleDoc}\n\n`;
        }
      }
    }
    markdownContent += "---\n\n";
  }
}

await Deno.writeTextFile(outputMdPath, markdownContent);
